# -*- coding: utf-8 -*-

'''
 1차
 - 알파벳을 숫자로 치환.
'''
def solution(word):
    answer = 0
    
    word_dic = {'A' : 1, 'E' : 2, 'I' : 3, 'O' : 4, 'U' : 5}
    
    new_list = []
    
    start = 0
    a = ''
    
    for i, j in word_dic.items():
        for k in word:
            if i in k:
                a += str(j)
        new_list.append(a)
        
    b = int('{:0<5}'.format((new_list[-1])))
    
    
    return b

###############################################################

'''
 2차
 - 모음으로만 구성된 단어의 최대 길이는 5.
 최대 길이 단어에서 제일 끝 인덱스가 그 다음 인덱스로 넘어가기 위해서는 6번의 단어 변경 횟수 필요.
 
 그 다음 인덱스(2번 인덱스)로 넘어가기 위해서는 6 x 5 = 30 에 +1 만큼인 31회 -> 'AAA' -> 'AAE'가 되려면
 3번 인덱스에 처음에 A가 들어온 후 (+1) 4번 인덱스가 6번씩 총 5회 (30)
 
 그 다음 인덱스(1번 인덱스)로 넘어가기 위해서는 31 x 5 = 155에 +1 만큼인 156회 -> 'AA' -> 'AE'가 되려면
 2번 인덱스에 처음 A가 들어온 후(+1) 2번 인덱스가 한번 바뀌는데 필요한 31회가 총 5회 반복(31 x 5)
 
 마 지막으로 0번 인덱스로 넘어가기 위해서는 156 x 5 = 780에 +1 만큼인 781회 -> 'A' -> 'E'가 되려면
 1번 인덱스에 A가 들어온 후(+1), 1번 인덱스가 한 번 하뀌는데 필요한 156회 가 총 5번 반복 (156 x 5)
 
 - 위 과정을 통해 나온 각 인덱스가 바뀌기 위한 횟수를 리스트로 만든다.
 
 - 각 단어에 번호를 부여한 딕셔너리를 만든다.
  -> A가 0인 이유는 A하나만 들어온 경우가 1번 이고, 이후 각 인덱스를 채워가며 A가 추가 되고 번호도 1씩 증가 한다.
   따라서 길이가 5이고, 모두 A로 채워진 단어가 5번인데, 만약 A를 1로 부여하면, 인덱스가 변경 될 때 필요한 횟수가 저장된
   리스트와 곱을 해줄 떄, A의 인덱스가 변경 된 인덱스로 인식되기 때문에 0으로 준다.
   
 - for문으로 주어진 word를 돌며 각 인덱스에 있는 모음에 설정된 단어와 해당 인덱스의 위치에 따라 변경 횟수를 곱해준다.
 이 과정을 각 인덱스 마다 진행해 주고, 모두 더해준다. 이 때, 다음 인덱스로 넘어가기 위해서는 공백의 인덱스에 A가 추가 된 후
 과정이 진행 되어야 하기 때문에 1을 더해 준다.
 
'''

def solution(word):
    answer = 0
    
    word_dic = {'A' : 0, 'E' : 1, 'I' : 2, 'O' : 3, 'U' : 4}
    
    convert = [781, 156, 31, 6, 1]
    
    for i in range(len(word)):
        answer += word_dic[word[i]] * convert[i]
        answer += 1
        
    return answer

print(solution("AAAAE"))
print(solution("AAAE"))
print(solution("I"))
print(solution("EIO"))